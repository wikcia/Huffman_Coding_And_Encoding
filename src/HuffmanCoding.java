import java.io.*;
import java.util.*;

public class HuffmanCoding {

    private static TreeNode root = null;
    private static final ArrayList<String> outputString = new ArrayList<>();
    /**
     * function to print Huffman's code
     */
    public static void printCode(TreeNode root, String s) {

        // if left and right nodes are null then it is a leaf
        // the code s generated by traversing the tree.
        try {
            if (root.left == null && root.right == null) {

                // c is the character in the node
                System.out.println(root.c + ":" + s);

                return;
            }

            // if we go to left then add "0" to the code
            // if we go to the right add "1" to the code

            printCode(root.left, s + "0");
            printCode(root.right, s + "1");
        } catch (NullPointerException e){
            System.out.println("Tree is empty");
        }
    }

    /**
     * function to create binary tree
     */
    private static void createTree(int n, Character[] charArray, double[] charFreq) {
        // we make a min-priority queue
        // n is initial capacity of the queue
        // for example 1->4->8 etc. head is the smallest number
        PriorityQueue<TreeNode> q = new PriorityQueue<>(n, new MyComparator()); // queue is our tree

        for (int i = 0; i < n; i++) {

            TreeNode treeNode = new TreeNode();

            treeNode.c = charArray[i];
            treeNode.probability = charFreq[i];

            treeNode.left = null;
            treeNode.right = null;

            q.add(treeNode);
        }

        // Here we will extract the two minimum value
        // from the heap each time until
        // its size reduces to 1, extract until
        // all the nodes are extracted.
        while (q.size() > 1) {

            // first min extract.
            // peek() retrieves, but does not remove, the head of this queue, or returns null if this queue is empty
            // poll() retrieves and removes the head of this queue, or returns null if this queue is empty.
            TreeNode x = q.peek();
            q.poll();

            // second min extract.
            TreeNode y = q.peek();
            q.poll();

            // new node f which is equal
            TreeNode f = new TreeNode();

            // to the sum of the frequency of the two nodes
            // assigning values to the f node.
            f.probability = x.probability + y.probability;
            f.c = '-';

            // first extracted node as left child.
            f.left = x;

            // second extracted node as the right child.
            f.right = y;

            // marking the f node as the root node.
            root = f;

            // add this node to the priority-queue.
            q.add(f);
        }

        // print the codes by traversing the tree
        printCode(root, "");
    }

    public static void main(String[] args) throws IOException {

        String filepath = args[0];

        Character[] resultsArray = getNonRepetitiveArrayOfChars(filepath); //gitara tablica znakow bez powtorzen, do zakodowania tekstu
        List<Double> frequency = new ArrayList<>();
        List<Character> characters = new ArrayList<>();
        List<Integer> occurrencesInAnArray = new ArrayList<>();

        try (BufferedReader br = new BufferedReader(new FileReader(filepath))) {

            // Read data into the list of characters

            while(br.ready()) {
                char ch = (char) br.read();
                characters.add(ch);
            }

            char[] fileContent = new char[characters.size()];

            // we write the list of characters to the array
            for(int i = 0; i < characters.size(); i++) {
                fileContent[i] = characters.get(i);
            }

            // count frequencies of characters in array using Hashmap
            countFrequenciesOfCharacters(occurrencesInAnArray, fileContent);

            double[] probabilityArray = getProbabilityOfACharacter(frequency, occurrencesInAnArray, fileContent);

            getEntropy(probabilityArray);

            createTree(resultsArray.length, resultsArray, probabilityArray);

            System.out.println("Entropy: " + getEntropy(probabilityArray));

            // in this map key is character, and value its Huffman code
            Map<Character,Double> map = new HashMap<Character,Double>();
            for(int i = 0; i < resultsArray.length; i++) {
                map.put(resultsArray[i], probabilityArray[i]);
            }
            HuffmanDecoding huffmanDecoding = new HuffmanDecoding(map);

            Map<Character,String> encodedMap = huffmanDecoding.getEncodingMap();
            //
            for (char c : fileContent) {
                for (char m : encodedMap.keySet()) {
                    if (c == m) {
                        String elementOfTheMap = encodedMap.get(m);
                        outputString.add(elementOfTheMap);
                    }
                }
            }
            String str = getStringMadeUpOfZerosAndOnes();
            System.out.println("Decoded Huffman data:");
            HuffmanDecoding.decode(str);
            System.out.println();
        }

        catch (FileNotFoundException e) {
            System.out.println("File not found" + e);
        }

        catch (IOException ioe) {
            System.out.println("Exception while reading file " + ioe);
        }
    }

    /**
     * function to get String made up of zeros and ones used to encode decoded Huffman data
     */
    private static String getStringMadeUpOfZerosAndOnes() {
        Object[] stringArray = outputString.toArray();
        StringBuffer stringBuffer = new StringBuffer();
        for (Object s : stringArray) {
            stringBuffer.append(s);
        }
        String str = stringBuffer.toString();
        return str;
    }

    /**
     * function to evaluate entropy of the encoded data
     */
    private static double getEntropy(double[] probabilityArray) {
        double entropy = 0;
        for (double v : probabilityArray) {

            // calculate the next value to sum to previous entropy calculation
            double value = v * customLog(v);

            entropy = entropy + value;
        }
        entropy = entropy * -1;
        return entropy;
    }

    /**
     * function to evaluate probability of a single Character
     */
    private static double[] getProbabilityOfACharacter(List<Double> frequency, List<Integer> occurrencesInAnArray, char[] fileContent) {
        for (int j : occurrencesInAnArray) {
            if (j != 0) {
                double probabilityOfCharacter = (double) j / fileContent.length;
                frequency.add(probabilityOfCharacter);
            }
        }
        double[] probabilityArray = new double[frequency.size()];

        for(int i = 0; i < frequency.size(); i ++) {
            probabilityArray[i] = frequency.get(i);
        }
        return probabilityArray;
    }

    /**
     * function to count frequency of all characters occurring in the file
     */
    private static void countFrequenciesOfCharacters(List<Integer> occurrencesInAnArray, char[] fileContent) {
        HashMap<Character, Integer> charCountMap = new HashMap<>();
        for (char c : fileContent) {
            if (charCountMap.containsKey(c)) {

                // If char is present in charCountMap,
                // incrementing it's count by 1
                charCountMap.put(c, charCountMap.get(c) + 1);
            }
            else {
                // If char is not present in charCountMap,
                // putting this char to charCountMap with 1 as it's value
                charCountMap.put(c, 1);
            }
        }
        for (Map.Entry entry : charCountMap.entrySet()) {
            occurrencesInAnArray.add((Integer) entry.getValue());
        }
    }

    /**
     * function to get every character but without repetitions
     */
    private static Character[] getNonRepetitiveArrayOfChars(String filepath) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(filepath));
        Set<Character> hashSet = new LinkedHashSet<>();

        // read and print characters one by one, by converting into character
        while (br.ready()) {
            int ch = br.read();
            hashSet.add((char) ch);
        }

        return hashSet.toArray(new Character[0]);
    }

    /**
     * function to evaluate the value of a logarithm with a custom base
     */
    private static double customLog(double logNumber) {
        return Math.log(logNumber) / Math.log(2);
    }

}
